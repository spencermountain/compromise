import*as t from"fs";import e from"path";import{fileURLToPath as n}from"url";import{Worker as o}from"worker_threads";import r from"os";var s={lib:{streamFile:function(e,n,o={}){const r=this,s=r.world(),c=r.methods().one.tokenize.splitSentences,i=t.createReadStream(e,o);let a="";const u=[],l=t=>{const e=r(t),o=n(e);o&&o.found&&o.docs.forEach((t=>u.push(t)))};return new Promise(((t,e)=>{i.on("data",(function(t){a+=t;const[e,n]=function(t){const e=a.substring(t.length-300),n=c(e,s),o=n[n.length-1];return[t.substr(0,t.length-o.length),o]}(a);l(e),a=n})),i.on("end",(function(){l(a);const e=r("");e.document=u,t(e)})),i.on("error",(function(t){console.error(t.stack),e(t)}))}))}}};const c={};var i={lib:{keyPress:function(t,e,n={}){const o=this,r=(0,this.methods().one.tokenize.splitSentences)(t,this.world()),s=[];return r.forEach((t=>{if(!0===c.hasOwnProperty(t))s.push(c[t].data),c[t].used=!0;else{n.verbose&&console.log(`parsing: '${t}'\n`);const r=o(t,e).json(0);c[t]={data:r,used:!0},s.push(r)}})),Object.keys(c).forEach((t=>{!0!==c[t].used?delete c[t]:c[t].used=null})),n.verbose&&console.log(`${Object.keys(c).length}' sentences in cache\n`),o(s)}}};const a=function(t,e,n=1){let o=function(t,e=1){const n=Math.ceil(t.length/e),o=new Array(e);for(let r=0,s=0;r<e;++r,s+=n)o[r]=t.substr(s,n);return o}(t,n);return o=function(t,e){const n=e.world(),o=e.methods().one.tokenize.splitSentences;for(let e=1;e<t.length;e+=1){const r=o(t[e].substr(0,200),n)[0],s=r.length;t[e-1]+=r,t[e]=t[e].substring(s)}return t}(o,e),o},u=e.dirname(n(import.meta.url)),l=r.cpus().length;var h={lib:{workerPool:function(t,n){const r=this;"string"==typeof n&&(n=r.parseMatch(n));const s=function(t,n){const r=[];for(let s=0;s<t;s+=1){const c={workerData:{workerIndex:s,workerCount:t,reg:n}},i=e.join(u,"./worker.js"),a=new o(i,c);a.on("error",(t=>console.error(t))),r.push(a)}return r}(l,n),c=a(t,r,l),i=[],h=s.map((t=>!0));return s.forEach(((t,e)=>{t.postMessage({type:"work",work:c[e]||[]})})),new Promise((t=>{s.forEach((e=>{e.on("message",(e=>{if("match"===e.type&&e.match.forEach((t=>{i.push(t)})),"drained"===e.type){const n=e.status.workerIndex;if(h[n]=!1,h.every((t=>!1===t))){const e=r("");e.document=i,s.forEach((t=>t.terminate())),t(e)}}}))}))}))}}};const f=function(t,e){const n=function(t){return Object.keys(t.hooks).filter((t=>!t.startsWith("#")&&!t.startsWith("%")))}(e);if(0===n.length)return t;t._cache||t.cache();const o=t._cache;return t.filter(((t,e)=>n.some((t=>o[e].has(t)))))};var m={lib:{lazy:function(t,e){let n=e;"string"==typeof e&&(n=this.buildNet([{match:e}]));const o=this.tokenize(t),r=f(o,n);return r.found?(r.compute(["index","tagger"]),r.match(e)):o.none()}}};const d={lib:Object.assign({},s.lib,i.lib,h.lib,m.lib),version:"0.1.2"};export{d as default,i as keyPress,m as lazyParse,s as streamFile,h as workerPool};
